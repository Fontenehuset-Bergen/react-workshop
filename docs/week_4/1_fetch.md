# Data fetching i React

Fram til n√• har vi jobbet hovedsakelig med statisk lokal data for √• teste funksjonaliteten i React, vi skal n√• ta steget inn i data fetching verdenen hvor vi bruker dynamisk informasjon til √• vise nettsiden.
Dette emnet er ganske komplekst med mange systemer som kommuniserer mellom hverandre for at vi skal kunne motta data vi kan jobbe med. Vi rekket ikke √• g√• igjennom alle punktene, men for de som er interessert har jeg litt ressurser til dere

- Javascript Fetch api [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) [W3Docs](https://www.w3docs.com/learn-javascript/fetch-api.html)
- Javascript Fetch examples [Javascript tutorials](https://www.javascripttutorial.net/web-apis/javascript-fetch-api/) [Sling (typescript)](https://www.slingacademy.com/article/using-fetch-api-with-typescript-tutorial-examples/)

## Hva er fetching

[Fetching](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) er prossen av √• hente data over nett (http) via javascript og er tilgjengelig i Node som serveren v√•r kj√∏rer p√• og i de fleste nettlesere. Fetch er en s√•kalt [asynkron](https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous) funksjon som returnerer et [Promise](https://developer.mozilla.org/en-US/docs/Glossary/Promise) vi m√• l√∏se ved √• bruke n√∏kkelordet [await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)

```ts
export async function MyExample() {
  // Vi kaller f√∏rst endepunket for √• hente noe data
  const response = await fetch("https://www.example.com/api");

  // Vi kan s√• sjekke om vi fikk noe data tilbake
  if (!response.ok) {
    // Her kan vi h√•ndtere hva som skal skje hvis fetch failet
  }

  // Vi m√• s√• hente ut riktig data format fra respons f√∏r vi kan bruke det
  // Her finnes det mange forskjellige typer, s√• les p√• api'en du spurte om hvilken du mottar
  const data = await response.json();
  return data;
}
```

Vi har flere [http metoder](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods) vi kan bruke med fetch, som default bruker `fetch` [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/GET) metoden som henter data fra en server, men vi kan ogs√• bruke [POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/POST) metoden som sender & mottar data. POST blir veldig ofte brukt til √• submitte form data fra brukere til serveren. Du kan se et eksempel under, vi kommer til √• jobbe med forms [neste uke](../week_5/1_forms.md)

```ts
export async function PostForm(formData: FormData) {
  // Vi kaller endepunket for √• sende inn data
  const response = await fetch(, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(formData)
  });

  // Vi kan s√• sjekke om vi fikk en feilmelding
  if (!response.ok) {
    // Her kan vi h√•ndtere hva som skal skje hvis post failet
  }

  // Vi kan s√• se hvilken melding vi fikk tilbake fra serveren
  const data = await response.json();
  return data;
}
```

## Begreper vi m√• forst√•

Her har jeg samlet en liten liste over begreper som kommer opp n√•r vi jobber med fetching

### Async

Betyr at koden ikke stopper opp mens vi venter p√• at noe skal skje, i stedet fortsetter programmet √• kj√∏re, og h√•ndterer resultatet n√•r det er klart.
Dette er n√∏dvendig fordi nettverkskall ofte tar tid ‚Äî vi vil ikke fryse hele nettsiden mens vi venter.

### Await

await brukes inne i en async funksjon for √• si ‚Äúvent til denne handlingen er ferdig f√∏r du g√•r videre‚Äù. Det lar oss skrive asynkron kode som ser mer ut som vanlig, trinnvis logikk.

```ts
// await ‚Äúpauser‚Äù funksjonen til fetch() har f√•tt ferdig svaret, uten √• blokkere resten av appen.
const res = await fetch("/api");
const data = await res.json();
```

### Promises

Et Promise er et objekt som representerer en verdi som ikke finnes enda. `fetch()` returnerer et Promise som ‚Äúlover‚Äù √• gi deg et resultat senere (enten fulfilled eller rejected).
Du bruker await for √• hente ut verdien fra et promise

### Headers

Headers (HTTP-hoder) er ekstra informasjon som sendes med foresp√∏rselen eller svaret. Typiske headers kan v√¶re:

- `Content-Type` ‚Üí forteller hvilket format vi sender eller mottar (f.eks. application/json)
- `Authorization` ‚Üí brukes for tokens / innlogging
- `Accept` ‚Üí spesifiserer hvilket dataformat vi √∏nsker fra serveren

```ts
await fetch("/api", {
  headers: {
    "Content-Type": "application/json",
    Authorization: "Bearer <token>",
  },
});
```

### Response

N√•r fetch() er ferdig, f√•r vi et Response-objekt tilbake. Dette objektet inneholder blant annet:

- `status` ‚Üí HTTP-statuskode (200 OK, 404 Not Found, 500 Internal Server Error)

- `ok` ‚Üí true hvis statusen er mellom 200‚Äì299

- `json()`, `text()`, `blob()` ‚Üí metoder for √• lese selve innholdet

```ts
const res = await fetch("/api");
if (!res.ok) throw new Error(`Feil: ${res.status}`);

const data = await res.json();
const text = await res.text();
```

### Caching

Caching betyr at nettleseren (eller serveren) lagrer tidligere foresp√∏rsler slik at de kan hentes raskere neste gang. Fetch st√∏tter dette automatisk via HTTP-headere som Cache-Control.
Dette kommer innebygd i React Router, men vi kan tvinge fram funksjonaliteten ved √• skrive `force-cache`

```ts
fetch("/api", { cache: "no-store" }); // hent alltid fersk data
fetch("/api", { cache: "force-cache" }); // bruk lagret versjon hvis mulig
```

## Hvordan er fetching forskjellig i React

```ts
import { useEffect, useState } from "react";

function UsersPage() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch("https://api.example.com/users")
      .then(res => res.json())
      .then(data => setUsers(data))
      .finally(() => setLoading(false));
  }, []);

  if (loading) return <p>Laster...</p>;

  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

hydration
loading states
hooks

## Hvordan bruker vi fetch i React Router

I vanlig React bruker vi ofte `useEffect()` og `useState()` for √• hente data. Dette fungerer, men har noen ulemper: data hentes etter at komponenten har rendret, og vi m√• selv h√•ndtere loading-, error- og re-render-logikk.
React Router (fra versjon 6.4 og opp) introduserte en ny m√•te √• hente data p√• ‚Äî via s√•kalte loaders som vi har sett p√• tidligere i dynamiske routes. Disse funksjonene kj√∏rer f√∏r komponenten rendres, og gj√∏r det enklere √• h√•ndtere asynkron data, feilh√•ndtering og caching direkte i rutene dine.

Med React Router definerer vi en loader p√• ruteniv√•. Denne kj√∏rer p√• serveren (ved SSR) eller i nettleseren (ved klientnavigasjon) f√∏r komponenten vises.

```ts
export async function loader() {
  const res = await fetch("https://api.example.com/users");
  if (!res.ok) throw new Response("Feil ved henting", { status: res.status });
  return res.json();
}
```

I komponenten kan vi deretter bruke useLoaderData():

```ts
import { useLoaderData } from "react-router";

export function UsersPage() {
  const users = useLoaderData() as User[];

  return (
    <ul>
      {users.map(u => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

Vi kan ogs√• ligge p√• en s√•kalt `AbortController` i fetch funksjonen v√•r for enda bedre h√•ndtering av respons. Hvis brukerene kjapt navigerer p√• siden din kan det hende at flere fetch foresp√∏rsler blir sendt nesten samtidig, ved √• ligge til [signal](https://developer.mozilla.org/en-US/docs/Web/API/Request/signal) i fetch objektet kan vi kontrollere om en fetch skal avsluttes tidlig.
```ts
export async function loader({ request }: { request: Request }) {
  const res = await fetch("https://api.example.com/users", {
    signal: request.signal,          // <- viktig!
  });
  if (!res.ok) throw new Response("Feil", { status: res.status });
  return res.json();
}
```

## Biblioteker som gj√∏r fetching lettere

N√•r prosjektene v√•re blir st√∏rre, kan det bli tungvint √• h√•ndtere all datahenting manuelt med `fetch()`, `useEffect()` og `useState()`.
Det finnes mange biblioteker og rammeverk som gj√∏r fetching, caching og synkronisering enklere og mer effektivt.
Her er noen av de mest brukte:

### React Query (TanStack Query)

- Henter og cacher data automatisk
- Oppdaterer data i bakgrunnen n√•r brukeren g√•r tilbake til siden
- Viser ‚Äúloading‚Äù og ‚Äúerror‚Äù-tilstand uten ekstra state-h√•ndtering
- Har st√∏tte for refetch, pagination, infinite scroll og mer

```ts
import { useQuery } from '@tanstack/react-query';

function Users() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });

  if (isLoading) return <p>Laster...</p>;
  if (error) return <p>Kunne ikke hente brukere üò¢</p>;

  return (
    <ul>
      {data.map((u: User) => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

### Next.js (alternativ til React Router)

Next.js er et rammeverk bygget p√• React som tar fetching enda et steg videre, dette er for√∏vrig rammeverket vi bruker p√• jobben min.

- Server Components lar deg hente data direkte p√• serveren, uten fetch i klienten
- Automatisk caching og revalidasjon via fetch() og revalidate
- Parallelle data-kall, streaming, og ISR (Incremental Static Regeneration)
- Perfekt for apper med behov for b√•de SEO og h√∏y ytelse

```ts
export default async function UsersPage() {
  const res = await fetch('https://api.example.com/users', { next: { revalidate: 60 } });
  const users = await res.json();

  return (
    <ul>
      {users.map((u: User) => <li key={u.id}>{u.name}</li>)}
    </ul>
  );
}
```

<table width="100%">
  <tr>
    <td><a href="README.md">‚Üê Tilbake</a></td>
    <td align="right"><a href="2_hooks.md">Hooks ‚Üí</a></td>
  </tr>
</table>
